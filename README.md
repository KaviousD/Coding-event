1. Big O Notation
Insertion Sort
Time Complexity:
Worst Case: O(n^2) (e.g., when the list is sorted in reverse)
Best Case: O(n) (e.g., when the list is already sorted)
Average Case: O(n^2) (e.g., for a randomly ordered list)
Space Complexity: O(1) (Uses a constant amount of extra space)
Reverse Linked List
Time Complexity: O(n) (Each node is visited once)
Space Complexity: O(1) (Uses a constant amount of extra space)
2. Sorting Algorithms
Quick Sort
What it Does: Picks a "pivot" and sorts elements into two groups (less than and greater than the pivot), then sorts the groups.
Performance:
Average Case: O(n log n)
Worst Case: O(n^2) (e.g., if the pivot is always the smallest or largest element)
Bubble Sort
What it Does: Repeatedly compares and swaps adjacent elements until the list is sorted.
Performance:
Worst Case: O(n^2) (e.g., when the list is in reverse order)
Best Case: O(n) (e.g., when the list is already sorted)
Insertion Sort
What it Does: Builds the sorted list one item at a time by inserting each item into its correct position.
Performance:
Worst Case: O(n^2) (e.g., when the list is in reverse order)
Best Case: O(n) (e.g., when the list is already sorted)
3. Dijkstra's Algorithm
What it Does: Finds the shortest path from a starting point to all other points in a graph.
Applications:
GPS Navigation: Helps find the shortest route on a map.
Network Routing: Determines the quickest path for data in computer networks.
How It Works:

Start from the source node and set its distance to zero.
Update distances to neighboring nodes.
Repeat until all nodes have been processed. 
